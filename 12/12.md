iOS Akademija

# Predavanja / 12

Finalna nedelja :)

---

# iOS dev

Da vidimo prvo Å¡ta su notifikacije.

## Notifications

Srce ove priÄe su dve klase:

* [NotificationCenter](https://developer.apple.com/reference/foundation/NotificationCenter)
* [Notification](https://developer.apple.com/reference/foundation/notification) struct u Swiftu mapiran iz [NSNotification](https://developer.apple.com/reference/foundation/nsnotification) klase u Objective-C svetu.

Ovaj sistem predstavlja implementaciju tzv. _Broadcast_ patterna unutar jedne app. Zamislite ga kao stari dobri radio: emitovanje sa jednog mesta u â€œpraznoâ€ i bilo ko da â€œnamesti frekvencijuâ€ moÅ¾e da prima taj signal.

To je suÅ¡tina: jedan objekat moÅ¾e da â€œobjaviâ€ informaciju bez da zna da li Ä‡e je iko primiti. NeograniÄen broj drugih objekata moÅ¾e da se â€œpretplatiâ€ i â€œsluÅ¡aâ€. Kada informacija stigne, onda sam primalac odluÄi Å¡ta Ä‡e s time uraditi.

### Kako se kreira

(1) DeklariÅ¡ete ime notifikacije (`String`), obiÄno `static let` na srodnoj klasi

(2) Od String konstante (`ime`) se onda pripremi `Notification.Name(rawValue: ime)`

To se moÅ¾e uraditi na dva naÄina. Ovo je kako se radi u iOS SDK-u, ali je bljak.

```swift
extension Notification.Name {
	static let DataManagerDataPreloadCompleted = "DataManagerDidCompletePreloadDataNotification"
}

let name = Notification.Name(Notification.Name.DataManagerDataPreloadCompleted)
```

Bolje je ovako:

```swift
extension DataManager {
	enum Notify: String {
		case dataPreloadCompleted = "DataManagerDidCompletePreloadDataNotification"

		var name: Notification.Name {
			return Notification.Name(rawValue: self.rawValue)
		}
	}
}

let name = Notify.dataPreloadCompleted.name
```

(3) Kada treba da se poÅ¡alje notifikacija, onda se prvo pripremi Notification struct:

```swift
let userInfo: [String: Any]? = nil
let notification = Notification(name: name, object: self, userInfo: userInfo)
```

`object` je objekat koji Å¡alje notifikaciju, na primer `DataManager`. Notifikacije se gotovo iskljuÄivo Å¡alju unutar opsega neke klase, otuda i `self` u primeru.

`userInfo` je (opcioni) dictionary sa bilo kojim String kljuÄevima i bilo kojim vrednostima koje Å¾elite da poÅ¡aljete kao dodatne informacije uz notifikaciju.

```swift
NotificationCenter.default.post(notification)
```

I time je posao na strani slanja zavrÅ¡en.

### Kako se sluÅ¡a

Da bi se bilo koji drugi objekat prijavio da â€œsluÅ¡aâ€ notifikacije, potrebno je negde u `viewDidLoad` (ili Äak u `init`u, ako je moguÄ‡e) uraditi prijavu:

```swift
NotificationCenter.default.addObserver(forName: DataManager.Notify.dataPreloadCompleted.name, object: nil, queue: nil) {
		[weak self] notification in
		guard let `self` = self else { return }

		//processing
}
```

Ako je `object: nil` onda nije bitno koji objekat je poslao notifikaciju; biÄ‡e svakako primljena. Ako je tu podeÅ¡en neki konkretan objekat, onda samo ako je on poÅ¡iljalac.

`queue` je tipa `OperationQueue` i ako je `nil`, onda Ä‡e se procesiranje izvrÅ¡iti na threadu iz koga je notifikacija poslata. Ako Å¾elite da forsirate mainQueue / thread, stavite `OperationQueue.main`

### Korisni resursi

* [Fundamentals of NSNotificationCenter](https://www.andrewcbancroft.com/2014/10/08/fundamentals-of-nsnotificationcenter-in-swift/) in Swift
* [NSNotificationCenter vs Delegation](https://www.andrewcbancroft.com/2015/02/05/nsnotificationcenter-vs-delegation-analysis/) â€“ An Analysis
* [Build your own NotificationCenter](https://wezzard.com/2015/08/08/notification-handling-best-practice-in-swift/) ğŸ˜…

OdliÄan video resurs: [Typed Notifications](https://talk.objc.io/episodes?tag=Notifications) sa Swift Talk-a.

# Core Data

Zapamtite: `fetch()` je skupa operacija, jer Äesto ide do fajla na disku da proÄita podatak. Stoga se uvek treba truditi da se smanji broj operacija koje se proÄitaju.

To se pogotovo odnosi na situacije _bulk_ importa, kada ne treba samo upisivati nove podatke veÄ‡ je potrebno prvo proveriti da li neki od njih veÄ‡ postoje. Fetch za svaki objekat bi bila [totalna katastrofa](https://medium.com/ios-os-x-development/how-i-deleted-10k-lines-of-code-turned-2-minutes-into-1-second-66e370d53436) po performanse aplikacije.

Å ta treba raditi:

0. Pobrini se da ti svaki objekat u Core Data ima neki jedinstven ID (artistId, albumId)
1. IzvuÄeÅ¡ sve ID-eve objekata iz novopridoÅ¡log JSON niza
2. UradiÅ¡ fetch objekata iz Core Data sa tim ID-evima. IzvuÄeÅ¡ Set ID-eva objekata koji su vraÄ‡eni.
3. UporediÅ¡ ta dva Seta i napraviÅ¡ _inserted_, _updated_ i (ako treba) _deleted_ podsetove.
4. One koji su novi, kreiraÅ¡
5. One koji su postojeÄ‡i, dohvatiÅ¡ sve odjednom jednim fetchom i aÅ¾uriraÅ¡
6. Sve zastarele: obriÅ¡eÅ¡.
7. Sada ide jedan MOC.save() da sve to snimi

Ovaj sistem potencijalno znaÄi da se sa jednim `fetch` i jednim `save` moÅ¾e uraditi kompletan import.

---

# 3rd party libs: image cache

Efikasan download, storage i prikaz fotografija, pogotovo u komponentama tipa CollectionView gde su potrebne ultimativne performanse je vrlo teÅ¾ak zadatak.

Zbog toga je najbolje koristiti neki od gotovih alata koji taj cache formiraju i opremaju za vas. Aktuelni favorit je [Kingfisher](https://github.com/onevcat/Kingfisher) koji je odliÄan, pure Swift i ima [mnogo naprednih moguÄ‡nosti](https://github.com/onevcat/Kingfisher/wiki/Cheat-Sheet).