iOS Akademija

# Predavanja / 09



# iOS dev

Nova app: _Spotifier_. Kroz nju Ä‡emo nauÄiti:

* JSON
* Collection Views and Collection View Layouts
* Notifications
* Core Data

TakoÄ‘e utvrÄ‘ujemo i proÅ¡irujemo ranije steÄeno znanje:

* kreiranje modela podataka
* pravilna raspodela posla unutar same app
* Singleton, Delegate i proÅ¡irena MVC filozofija
* Rad sa viÅ¡e projekata kroz Xcode Workspaces


## Spotifier

Osnovne postavke:

* KoristiÄ‡emo `Main.storyboard` za inicijalno startovanje same app
* Ne koristimo _segues_, veÄ‡ Ä‡emo eventualno dodatno potrebne kontrolere â€œpodizatiâ€ kroz kod, kao u Valute app
* KoristiÄ‡emo Spotify Web API koji koristi JSON kao format za data transfer

Redosled posla, sliÄna priÄa kao za Valute app:

1. Smisli Å¡ta Å¾eliÅ¡ da uradiÅ¡ i kako da app funkcioniÅ¡e
2. Analiziraj izvor podataka (Spotify API)
3. Kreiraj data model u app tako da najpribliÅ¾nije odgovara cilju same app *plus* da je izvorne podatke moguÄ‡e transformisati u tu strukturu
4. Kreiraj app :)

Da bi znali Å¡ta je uopÅ¡te moguÄ‡e da dobijemo od podataka, moramo prvo da analiziramo API. 

Ima viÅ¡e alata koji nam u tome mogu pomoÄ‡i

* Sam Spotify ima mehanizam za testiranje: [API Console](https://developer.spotify.com/web-api/console/)
* Chrome plugin (extension): [Postman](https://www.getpostman.com)
* [Paw](https://paw.cloud), native Mac app

## Spotify API

* [Understanding the Spotify Web API](https://labs.spotify.com/2015/03/09/understanding-spotify-web-api/)

* [Web API Reference](https://developer.spotify.com/web-api/)

* [Endpoints reference](https://developer.spotify.com/web-api/endpoint-reference/)

* Primer JSON-a za [informacije o albumu](https://api.spotify.com/v1/albums/4aawyAB9vmqN3uQ7FjRGTy)

* Spotify razvija i [iOS SDK](https://developer.spotify.com/technologies/) za svoj servis âš ï¸

---

## JSON 

[JSON](http://json.org) je danas najpopularniji data transfer format. Vrlo je kompaktan, jednostavan i trivijalan i za kreiranje i za parsiranje. _Total win!_

Ima brdo resursa za uÄenje: [what is json](https://duckduckgo.com/?q=what+is+json)

* [JSON in 3 minutes](http://www.secretgeek.net/json_3mins)
* [What is JSON, how it works and how to use it](https://www.copterlabs.com/json-what-it-is-how-it-works-how-to-use-it/)

> OdliÄan resurs za lepo formatiranje JSON teksta: [JSON Lint](http://jsonlint.com)

### JSON u Swiftu

`typealias JSON = [String: Any]`

To je to. Dictionary gde su kljuÄevi uvek `String`, a vrednost moÅ¾e nominalno biti bilo Å¡ta, ali u praksi je to:

* `String`
* `Double`
* `Int`
* `Bool`
* `JSON`
* `[Any]`

Gde `Any` u `Array<Any>` takoÄ‘e moÅ¾e biti samo jedno od ovih ostalih tipova.

### Working with JSON

Parsiranje JSON formata i konvertovanje u Swift objekte je tokom vremena postalo omiljena igraÄka Swift programera, pogotovo onih koji su uÄili _generics_ i joÅ¡ viÅ¡e onih koji su ljubitelji funkcionalnog programiranja.

To je uzelo toliko maha i podivljalo u meri da je i Apple Swift Core team morao da [â€œinterveniÅ¡eâ€ na svom blogu](https://developer.apple.com/swift/blog/?id=37). ğŸ˜Œ
ProÄitajte taj blog post, nema niÄega u njemu Å¡to veÄ‡ ne znate iz Swifta.

#### Marshal

Moj trenutni (_Å¡ic!_) favorit je [Marshal](https://github.com/utahiosmac/Marshal) library. Razlog Å¡to sam ga izabrao je [sledeÄ‡ih par pasusa](http://jasonlarsen.me/2015/06/23/no-magic-json.html) originalnog autora (Jason Larsen):

> However, most solutions tend to rely on a lot of magic: the magic of applicatives, functors, and monads; the magic of unfamiliar custom operators; the magic of a complex nested enum structure; the magic of multiple external dependencies.

> Now that Swift 2.0 has brought error handling to us, *we can implement much less magical JSON parsing*. Here is an example of what your JSON parsing code might look like with just a thin error-throwing layer over `[String: AnyObject]`.

*ğŸ¶ for my ğŸ‘‚ğŸ»*

Ova biblioteka se interno duboko oslanja na Swift Generics ali je sreÄ‡na okolnost Å¡to mi ne moramo da znamo generics da bi mogli da koristimo biblioteku.

---

E sad, kako da Marshal library ukljuÄimo u naÅ¡ projekat?


## Xcode workspaces

TreÄ‡i projekat koji radimo je najkompleksniji koji imamo i posao Ä‡e biti kraÄ‡i i (nadam se) lakÅ¡i ako koristimo _3rd-party_ _open source_ _libraries_ / _frameworks_ koje su pisali drugi programeri (ne Apple).

Xcode podrÅ¾ava istovremeni rad sa viÅ¡e projekata kroz [Workspaces](https://developer.apple.com/library/ios/featuredarticles/XcodeConcepts/Concept-Workspace.html).

> Pogledajte i [Managing Xcode](http://pewpewthespells.com/blog/managing_xcode.html) by Samantha Marshall

Tokom godina iskristalisala su se dva Å¡iroko prihvaÄ‡ena koncepta za (koliko-toliko) automatizaciju koriÅ¡Ä‡enja 3rd-party koda u iOS svetu:

- [CocoaPods](https://cocoapods.org)
- [Carthage](https://github.com/Carthage/Carthage)

TakoÄ‘e se vrlo aktivno radi na Swift Package Manageru koji ima istu namenu - da se kod zapakuje kao eksterni modul i onda se jednostavno ukljuÄi u projekat kao eksterni _dependency_.

* [Package Manager](https://swift.org/package-manager/) on Swift.org
* An [Introduction to Swift Package Manager](https://www.raywenderlich.com/148832/introduction-swift-package-manager) on Ray Wenderlich

Mi Ä‡emo koristiti CocoaPods.

### CocoaPods

1. [Instalirajte](https://guides.cocoapods.org/using/getting-started.html) kroz Terminal
2. Nakon Å¡to se zavrÅ¡i, uradite `pod setup`

NaÄin koriÅ¡Ä‡enja za projekte:

1. Kreirajte projekat kao i obiÄno
2. dodaje `.gitignore` i commit-ujte sav taj kod
3. Otvorite osnovni folder za projekat u terminalu. IzvrÅ¡ite `pod init`
4. To Ä‡e kreirati `podfile` tekstualni fajl sa nekim osnovnim setupom
5. Sada otvorite taj fajl u bilo kom editoru i konfuguriÅ¡ete do mile volje. Minimalno: podesite platform deployment target i omoguÄ‡ite `use frameworks!`
6. Kada ste gotovi, nazad u terminal i kucate `pod install`. I ÄeeekaÅ¡â€¦
7. Kada se zavrÅ¡i, kreiraÄ‡e `.xcworkspace` fajl - od tog momenta za rad **uvek** koristite workspace, a ne sam projekat direktno

Ende. Nema viÅ¡e. 

#### pod template

```
 use_frameworks!

 abstract_target 'MYApp' do
	platform :ios, '10.0'

	pod 'Marshal'

 # Targets
	target 'App'
 end
```


Sve van ovoga su razni sitni detalji i naprednije moguÄ‡nosti, koji vam ponekad zatrebaju a onda radite isto Å¡to i za bilo koju drugu tehnologiju - [Äitate dokumentaciju](https://guides.cocoapods.org/using/index.html).

---

# Core Data

* [Core Data Programming Guide](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/)

Core Data nije baza podataka. Core Data je **objektni graf** (ÄiÄa GliÅ¡a struktura).

![](../assets/coredata-entity-graph.png)

Bukvalno crtate objekte koji su vam potrebni, kreirate osobine koje definiÅ¡u objekat i zatim ih povezujete u graf.

Time ste definisali *Data Model*.

### Kreiranje Data Modela

Prvo dodajemo odgovarajuÄ‡i fajl:

![](../assets/coredata-add-data-model.png)

Za kreiranje grafa objekata, koristi se Core Data Modeler, koji se automatski prikaÅ¾e kada u Project Navigatoru selektujete `.xcdatamodeld` fajl. 

Svaki objekat u grafu se modelira kao `Entity`. Svaki entitet ima:

- 1 ili viÅ¡e `Attributes` i 
- 0 ili viÅ¡e `Relationships`

## Swift reprezentacija modela

Da bi u kodu mogli da radimo sa entitetima, moramo kreirati njihov pandan u Swiftu. Za svaki od entiteta kreiramo odgovarajuÄ‡u subklasu od `NSManagedObject`.

Ime subklase se deklariÅ¡e putem _Data Model Inspector_ panela. ObiÄno se koristi ime entiteta.

![](../assets/coredata-model-inspector.png)

Xcode nudi 3 opcije za generisanje klasa. Preporuke:

- nikada ne koristite _Class definition_
- prihvatljiva opcija je _Category / Extension_
- najbolje: Manual opcija + `mogenerator` utility

### mogenerator

KoristiÄ‡emo open-source utility koji se zove [MO Generator](https://github.com/rentzsch/mogenerator). Inicijalno je napisan za Objective-C ali je naknadno dodata moguÄ‡nost da generiÅ¡e i Swift templates.

Ja koristim svoje custom MOgen templates za generisanje koda, jer su jednostavniji i Swift-olikiji od predefinisanih koje autori isporuÄuju.

(1) mogenerator se dodaje kao _New Target_ â†’ _Cross-platform_ â†’ _Aggregate_

(2) Zatim idete na _Build Phases_ tab, klik na `+` / _New Run Script Phase_

i tu stavite ovo:

```shell
cd DataModel

"${SRCROOT}/DataModel/tmpl/mogenerator" 
  --swift 
  --base-class ManagedObject
  --model Spotifier.xcdatamodeld 
  --template-path tmpl 
  --human-dir mogen-classes 
  --machine-dir mogen-properties
```

Ovo su bukvalno dve Terminal komande koje Ä‡e biti izvrÅ¡ene kada uradite â€œRunâ€ ovog targeta u Xcodeu. Svi parametri za mogenerator su opcioni, ali barem `â€”swift` je obavezan.

Sada je ostalo da generisane foldere dodate u projekat i to je to.

## Core Data Stack

Da bi u kodu mogli da radite sa ovim klasama i podacima koji stoje iza njih, potrebno je da se inicijalizuje *Core Data stack*.

![Osnovna arhitektura Core Data stack-a](../assets/coredatastack.jpg)

* [Core Data Reference](https://developer.apple.com/reference/coredata)
	* [NSManagedObjectModel](https://developer.apple.com/reference/coredata/nsmanagedobjectmodel) je klasa koja instancira sam model
	* [NSPersistentStoreDescription](https://developer.apple.com/reference/coredata/nspersistentstoredescription) je klasa koja opisuje _store_, odnosno fajl na disku
	* [NSPersistentStore](https://developer.apple.com/reference/coredata/nspersistentstorecoordinator) je klasa koja modelira vrstu store-a. Ova klasa zapakuje u sebe sve detalje implementacije Äitanja / pisanja za izabranu vrstu storea (SQlite, memory-only, XML, binary)
	* [NSPersistentStoreCoordinator](https://developer.apple.com/reference/coredata/nspersistentstorecoordinator) je klasa koja â€œpriÄaâ€ sa Store instancom iz prethodnog koraka. Ona je medijator izmeÄ‘u Contexta i Storea

### Process inicijalizacije Core Data stacka

1. Kreirajte URL gde Ä‡e se fiziÄki data file nalaziti. Dobro mesto je unutar `Library/Application Support` foldera
2. Instancirate `NSManagedObjectModel` na osnovu `.xcdatamodeld` fajla
3. Instancirate `NSPersistentStoreCoordinator`, koristeÄ‡i MOM instancu iz prethodnog koraka
4. Kreirate instancu `NSPersistentStoreDescription` koristeÄ‡i URL iz koraka 1
5. Dodate `NSPersistentStore` â€“ koristeÄ‡i opis iz prethodnog koraka â€“ na PSC (iz koraka 3)
6. Sada konaÄno imate stack spreman i moÅ¾ete kreirati main `ManagedObjectContext`

_Pheeewâ€¦_ ğŸ˜…

*Savet:* Izbegavajte da Å¡tiklirate `Use Core Data` kada kreirate Xcode project template. Ili barem taj kod odatle izvucite negde drugde.
Core Data stack nema Å¡ta da traÅ¾i u AppDelegate fajlu. Ako niÅ¡ta drugo, stack treba izvuÄ‡i u poseban fajl / klasu i koristiti kao singleton ili kao property AppDelegate.

> KoristiÄ‡emo [RTCoreDataStack](https://github.com/radianttap/RTSwiftCoreDataStack) by ğŸ˜, kroz CocoaPods.

PoÄev od iOS-a 10, Apple je u Core Data framework dodao [NSPersistentContainer](https://developer.apple.com/reference/coredata/nspersistentcontainer) klasu koja radi deo moguÄ‡nosti koje RTCoreDataStack veÄ‡ ima.


### KoriÅ¡Ä‡enje u aplikaciji

Ok, sada sledi serija klasa iz Core Data frameworka od interesa za rad sa objektima u samoj iOS aplikaciji:

* [NSEntityDescription](https://developer.apple.com/reference/coredata/nsentitydescription) je klasa koja opisuje entitet (objekat) u Core Data
* [NSManagedObject](https://developer.apple.com/reference/coredata/nsmanagedobject) - osnovna (_base_) klasa za sve vaÅ¡e objekte / entitete. Za kreiranje instance neophodno je da imamo instancu opisa iz prethodnog koraka (property `entity`)
* [NSManagedObjectID](https://developer.apple.com/reference/coredata/nsmanagedobjectid) je jedinstveni ID za svaku instancu koju snimite u Core Data. Ovo je tip `objectID` propertyja svakog NSManagedObject-a
* [NSManagedObjectContext](https://developer.apple.com/reference/coredata/nsmanagedobjectcontext) je klasa koja â€œdrÅ¾iâ€ sve konkretne objekte (instance NSMO) sa kojima radite u aplikaciji. â€œVezanaâ€ je ili direktno za NSPSC ili za neki drugi (parent) Context. NSMO instanca se kreira / Äita iskljuÄivo putem MOC instance.

_Pheeew, pheeewâ€¦_ ğŸ˜“ 
<small>(ima joÅ¡)</small>

Da proÄitamo podatke iz Core Data, moramo da instanciramo [NSFetchRequest](https://developer.apple.com/reference/coredata/nsfetchrequest), da mu opciono zadamo uslov i da obavezno zadamo barem jedan parametar za sortiranje.

Rezultat ovog _fetch_ jeste niz objekata traÅ¾enog entiteta koji zadovoljavaju dati uslov.

Posebno za rad sa tabelarnim prikazom, koriste se specijalna klasa [NSFetchedResultsController](https://developer.apple.com/reference/coredata/nsfetchedresultscontroller) i njen delegate pattern [NSFetchedResultsControllerDelegate](https://developer.apple.com/reference/coredata/nsfetchedresultscontrollerdelegate).
